#ifndef __FUNCTIONS_H_
#define __FUNCTIONS_H_

#include "structures.h"

/* The function that is called by each task in main in case that the system has no
errors
    @initialTopology -> the topology of each task
    @operationStruct -> the structure used for the multipling vector by each task 
    @rank -> the rank of each task
    @numberOfTasks -> the total number of tasks in the MPI_COMM_WORLD communicator
    @argv -> the input line argument values */
void noErrorSituation(Topology *initialTopology, OperationStruct *operationStruct,
                      int rank, int *myCoordinator, int numberOfTasks, char **argv);

/* The function that is called by each task in main in case that the system has just
a half error (process 0 and 1 cannot interact directly)
    @initialTopology -> the topology of each task
    @operationStruct -> the structure used for the multipling vector by each task 
    @rank -> the rank of each task
    @numberOfTasks -> the total number of tasks in the MPI_COMM_WORLD communicator
    @argv -> the input line argument values */
void halfErrorSituation(Topology *initialTopology, OperationStruct *operationStruct,
                        int rank, int *myCoordinator, int numberOfTasks, char **argv);

/* The function that is called by each task in main in case that the system has
a full error (the rest of topology cannot communicate with process 1)
    @initialTopology -> the topology of each task
    @operationStruct -> the structure used for the multipling vector by each task 
    @rank -> the rank of each task
    @numberOfTasks -> the total number of tasks in the MPI_COMM_WORLD communicator
    @argv -> the input line argument values */
void fullErrorSituation(Topology *initialTopology, OperationStruct *operationStruct,
                        int rank, int *myCoordinator, int numberOfTasks, char **argv);

/* The function used by the coordinators tasks in the no error situation to share their
own topology after they read it from the file
    @initialTopology -> the topology known by each of the tasks
    @rank -> the rank of each of the tasks */
void sendTopologyInCoordinators(Topology *initialTopology, int rank);

/* The function used by the coordinators tasks in the half error situation to share their
own topology in one direction after they read it from the file
    @initialTopology -> the topology known by each of the tasks
    @rank -> the rank of each of the tasks */
void sendTopologyInCoordinatorsOneWay(Topology *initialTopology, int rank);

/* The function used by the coordinators tasks in the half error situation to share their
own topology in the reverse direction after they read it from the file
    @initialTopology -> the topology known by each of the tasks
    @rank -> the rank of each of the tasks */
void sendTopologyInCoordinatorsReverseWay(Topology *initialTopology, int rank);

/* The function used by the coordinators tasks different from 1 in the full error
situation to share their own topology in the one way direction after they read it 
from the file
    @initialTopology -> the topology known by each of the tasks
    @rank -> the rank of each of the tasks */
void sendTopologyInCoordOneWayFullError(Topology *initialTopology, int rank);

/* The function used by the coordinators tasks different from 1 in the full error
situation to share their own topology in the reverse way direction after they read it 
from the file
    @initialTopology -> the topology known by each of the tasks
    @rank -> the rank of each of the tasks */
void sendTopologyInCoordReverseWayFullError(Topology *initialTopology, int rank);

/* The function used by the coordinators tasks, after they found out about the
full topology to send it their own workers
    @initialTopology -> the full topology known by each of the tasks
    @rank -> the rank of each of the tasks */
void sendTopologyToWorkers(Topology *initialTopology, int rank);

/* The function used by the workers to get the topology from their coordinators 
    @initialTopology -> the initial topology of the workers that is going to be populated
    @rank -> the rank of each of the tasks */
void receiveTopologyFromCoordinators(Topology *initialTopology, int *myCoordinator);

/* The function used by the coordinators to send the vector generated by the number 0 task
before any operations were done by the workers on the vector in case of a normal system with
no errors
    @operationStruct -> the structure for the mutiplying task 
    @rank -> the rank of the current task */
void sendVectorInCoordinators(OperationStruct *operationStruct, int rank);

/* The function used by the coordinators to send the vector generated by the number 0 task
before any operations were done by the workers on the vector in case of a half error system with
error between direct communication between task 0 and task 1
    @operationStruct -> the structure for the mutiplying task 
    @rank -> the rank of the current task */
void sendVectorInCoordinatorsHalfError(OperationStruct *operationStruct, int rank);

/* The function used by the coordinators to send the vector generated by the number 0 task
before any operations were done by the workers on the vector in case of a full error system with
task 1 being completly isolated from the other coordinators so this function is only called by
tasks 0, 2 and 3
    @operationStruct -> the structure for the mutiplying task 
    @rank -> the rank of the current task */
void sendVectorInCoordinatorsFullError(OperationStruct *operationStruct, int rank);

/* The function used by all the coordinators to send the full vector to their workers after they
got the initial vector from task number 0
    @initialTopology -> the topology of the clusters
    @operationStruct -> the structure from which we send the vector to the workers
    @rank -> the rank of the coordinator */
void sendVectorToWorkers(Topology *initialTopology, OperationStruct *operationStruct, int rank);

/* The function used by all the workers to receive the initial vector from their coordinator,
update a part of it and then send it back to the coordinator
    @initialTopology -> the topology of the clusters
    @operationStruct -> the structure where we store the vector from the coordinators
    @myCoordinator -> the coordinator of each of the workers
    @rank -> the rank of the coordinator 
    @numberOfWorkers -> the total number of workers 
    @taskOneWorkersFullError -> the number of workers task 1 have because in case of a full
    error we don't have to take them into consideration when splitting the vector because
    they are not accessible */
void receiveUpdateAndSendVectorBack(Topology *initialTopology, OperationStruct *operationStruct, int myCoordinator,
                                    int rank, int numberOfWorkers, int taskOneWorkersFullError);

/* The function used by all the coordinators to get the updated vector from their workers
    @initialTopology -> the topology of the clusters 
    @operationStruct -> the structure where we update the final vector by combining all the
    vectors from our workers and by comparing their vectors with the original one
    @rank -> the rank of the current task */
void receiveUpdatedVectorFromWorkers(Topology *initialTopology, OperationStruct *operationStruct, int rank);

/* The function used by the coordinators to combine their final vectors and send it back
to task 0 in order to be printed on the screen. This function is used in the case of a
normal working system with no errors
    @operationStruct -> the structure for the mutiplying task 
    @rank -> the rank of the current task */
void sendUpdatedVectorInCoordinators(OperationStruct *operationStruct, int rank);

/* The function used by the coordinators to combine their final vectors and send it back
to task 0 in order to be printed on the screen. This function is used in the case of a
half working system with error between task 0 and task 1 communication
    @operationStruct -> the structure for the mutiplying task 
    @rank -> the rank of the current task */
void sendUpdatedVectorInCoordinatorsHalfError(OperationStruct *operationStruct, int rank);

/* The function used by the coordinators to combine their final vectors and send it back
to task 0 in order to be printed on the screen. This function is used in the case of a
full error system with task 1 being completly inaccessible from other tasks
    @operationStruct -> the structure for the mutiplying task 
    @rank -> the rank of the current task */
void sendUpdatedVectorInCoordinatorsFullError(OperationStruct *operationStruct, int rank);

#endif /* __FUNCTIONS_H_ */